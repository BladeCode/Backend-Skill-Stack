# Java SE 基础
```
rc-cluster-jdk
    ├── basics/         # Java基础
    │   ├── elementary      # 初级
    │   ├── intermediate    # 中级
    │   └── advanced        # 高级
    ├── jdk8            # JDK8
    ├── jdk9            # JDK9
    ├── jdk10           # JDK10
    ├── README.md    
    └── LICENSE  
```
!> Java SE 相关示例代码请查看 [rc-cluster-jdk](https://github.com/RootCluster/rc-cluster-jdk) 项目

# 基本数据类型

 | 名称    | 范围             | 类型         | 位数        | 默认值                  | 包装类型 & 默认值 |
 | ------- | ---------------- | ------------ | ----------- | ----------------------- | ----------------- |
 | byte    | -2⁷ ~ (2⁷ - 1)   | 字节型       | 8位(1字节)  | 0                       | Byte(null)        |
 | int     | -2¹⁵ ~ (2¹⁵ - 1) | 整型         | 32位(4字节) | 0                       | Integer(null)     |
 | short   | -2¹⁵ ~ (2¹⁵ - 1) | 短整型       | 16位(2字节) | 0                       | Short(null)       |
 | long    | -2⁶³ ~ (2⁶³ -1)  | 长整型       | 64位(8字节) | 0L                      | Long(null)        |
 | float   | -2¹²⁸ ~ 2¹²⁸     | 单精度浮点型 | 32位(4字节) | 0.0f                    | Float(null)       |
 | double  | -2¹⁰²⁴ ~ 2¹⁰²⁴   | 双精度浮点型 | 64位(8字节) | 0.0d                    | Double(null)      |
 | boolean |                  | 布尔型       |             | false                   | Boolean(false)    |
 | char    | 0 ~ 65,535       | 字符型       | 16位(2字节) | '\u0000'(空格，长的为0) | Character(null)   |

>* char：Java本身的字符集不是用 [ASCII](https://ascii.cl) 码来进行存储，是使用的16位[`Unicode`](http://www.unicode.org)字符集，它的 **字符范围** 即是Unicode的字符范围
* 范围小的数据可以赋值给比自身数据范围大的变量，但不能直接赋值给比自身数据范围小的变量，需要进行 **强制类型转换**
>* Java中所有的浮点类型 (float,double) 默认为`double`类型
>* Float和long类型的必须加后缀

## 数据类型转换

* 整数值型：byte,short,int,long,
* 字符型：char
* 浮点类型：float,double
* 布尔型：boolean

**String**是引用类型，不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。
 而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型

# 进制

Java中主要进制

* 二进制：只有 **0** 和 **1** 组成
* 八进制：以 **0** 开头，由 **0** ~  **7** 组成
* 十进制：以 **1** ~ **9** 开头，由 **0** ~ **9** 组成
* 十六进制：以 **0X** 开头，**0** ~ **9** 或者 **A** ~ **F**(**a** ~ **f**)组成，其中：**A** ~ **F**表示 **10** ~ **15**

## 进制转换

* 【二、八、十六进制】 ↔ 【十进制】
    * 二进制 → 十进制
    * 八进制 → 十进制
    * 十六进制 → 十进制
    * 十进制 → 二进制
    * 十进制 → 八进制
    * 十进制 → 十六进制

* 【二进制】 ↔ 【八、十六进制】 
    * 二进制 → 八进制
    * 八进制 → 二进制
    * 二进制 → 十六进制
    * 十六进制 → 二进制

* 【八进制】 ↔ 【十六进制】
    * 八进制 → 十六进制
    * 十六进制 → 八进制

# 运算符

>int a = 10; int b = 20; boolean c = false; boolean d = true;

## 算术运算符

| 运算符 | 描述                                                | 例子        |
| ------ | --------------------------------------------------- | ----------- |
| +      | 加法 – 在运算符的另一端增加                         | a + B 为 30 |
| -      | 减法 – 将右侧的操作数从左侧的操作数中减去           | a - b 为-10 |
| *      | 乘法 – 将运算符两端的值相乘                         | a * b 为200 |
| /      | 除法 – 用右侧操作数除左侧操作数                     | a / b 为0   |
| %      | 取模（求余数） - 用右侧操作数除左侧操作数并返回馀数 | a % b 为10  |

>* 参与运算的若干个变量，结果类型 **取决于** 这些变量中表示 **范围最大** 的那个变量类型
* 取模（求余数）运算的结果的正负永远与 **被除数**即（a）的符号相同

## 关系运算符

| 运算符 | 描述                                                         | 例子            |
| ------ | ------------------------------------------------------------ | --------------- |
| ==     | 检查双方操作数的值是否相等，如果相等那么条件为真             | (a == b) 为假。 |
| !=     | 检查双方操作数的值是否相等，如果不相等那么条件为真           | (a != b) 为真。 |
| >      | 检查左侧的操作数是否大于右侧的操作数，如果大于那么条件为真   | (a > b) 为假。  |
| <      | 检查左侧的操作数是否小于右侧的操作数，如果小于那么条件为真   | (a < b) 为真。  |
| >=     | 检查左侧的操作数是够大于等于右侧的操作数，如果是那么条件为真 | (a >= b) 为假。 |
| <=     | 检查左侧的操作数是否小于等于右侧的操作数，如果是那么条件为真 | (a <= b) 为真。 |

## 位运算符

| 运算符 | 描述                                                                                   | 例子                                                           |
| ------ | -------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| &      | 二进制AND运算符在结果上复制一位如果在双方操作数同时存在                                | (A & B) 为12，即 0000 1100                                     |
| &#124; | 二进制OR运算符在结果上复制一位如果在任何一个操作数上存在                               | (A &#124; B) 为61，即0011 1101                                 |
| ^      | 二进制XOR 运算符复制位，如果它是设置在一个操作数上而不是两个                           | (A ^ B) 为49， 即0011 0001                                     |
| ~      | 二进制补充运算符是一元的，b并有“翻转”位的影响                                          | (~A ) 为 -61，由于是带符号的二进制数，那2的补位形式为1100 0011 |
| <<     | 二进制左移运算符。左侧操作数的值根据右侧操作数指定的位的数量移至左侧                   | A << 2 为240 ，即1111 0000                                     |
| >>     | 二进制右移运算符。左侧操作数的值根据右侧操作数指定的位的数量移至右侧                   | A >> 2 为 15即1111                                             |
| >>>    | 右移补零运算符。左侧操作数的值根据右侧操作数指定的位的数量移至右，并且转移的值用零补满 | A >>>2 为15 ，即0000 1111                                      |

## 逻辑运算符

| 运算符       | 描述                                                             | 例子                     |
| ------------ | ---------------------------------------------------------------- | ------------------------ |
| &&           | 称为逻辑与运算符。如果双方操作数都为真，那么结果为真             | (c && d) 为假.           |
| &#124;&#124; | 称为逻辑或运算符。如果双方操作数其中的任何一个为真，那么结果为真 | (c &#124;&#124; d) 为真. |
| !            | 称为逻辑非运算符。如果一个条件为真，那么逻辑非运算符为假         | !b 为真.                 |

## 赋值运算符

| 运算符  | 描述                                                                       | 例子                             |
| ------- | -------------------------------------------------------------------------- | -------------------------------- |
| =       | 简单及运算符, 将右侧操作数的值赋给左侧操作数                               | C = A + B 会将 A + B 的值赋给 C  |
| +=      | 增加及赋值运算符, 它将右侧的操作数增加到左侧的操作数并且结果赋给左侧操作数 | C += A 同等于 C = C + A          |
| -=      | 减去及赋值运算符，它将右侧操作数从左侧操作数中减去并将结果赋给左侧操作数   | C -= A 同等于C = C - A           |
| *=      | 乘以及赋值运算符，它将右侧操作数与左侧相乘并将结果赋给左侧操作数           | C = A 同等于 C = C A             |
| /=      | 除以及赋值运算符，它将右侧操作数除左侧操作数并将结果赋给左侧操作数         | C /= A 同等于 C = C / A          |
| %=      | 系数及赋值运算符 需要系数运用两个操作数并且将结果赋给左侧操作数            | C %= A is 同等于 C = C % A       |
| <<=     | 左移和赋值运算符                                                           | C <<= 2 同等于C = C << 2         |
| >>=     | 右移和赋值运算符                                                           | C >>= 2 同等于 C = C >> 2        |
| &=      | 按位和赋值运算符                                                           | C &= 2 同等于C = C & 2           |
| ^=      | 按位异或及赋值运算符                                                       | C ^= 2 同等于 C = C ^ 2          |
| &#124;= | 按位可兼或及赋值运算符                                                     | C &#124;= 2 同等于C = C &#124; 2 |

## 其它运算符

* 自增 & 自减
    * 自增、自减  
    `a++` 和 `++a` 等价；`a--` 和 `--a`等价；
    * 自增、自减（并赋值）
        * int a = b++; int a = b--;表示：先将b的值赋给a，然后自增(自减)b
        * int a = ++b; int a = --b;表示：先自增(自减)b，然后将自增(自减)后的值赋给a
* 条件运算符（？：）  
条件运算符也被称作为三元运算符。这种运算符由三个操作数组成，被用作评估布尔数学体系表达。这种运算符的目的是来决定哪些值应被赋予到变量上
```java
variable x = (expression) ? value if true : value if false 
```
* Instanceof 符  
这种操作符只用于对象引用变量。这种操作符检查对象是否是独特类型（类型或接口类型）
```java
( Object reference variable ) instanceof  (class/interface type)
```

# 流程控制语句

## 条件语句

### if 语句

```java
if ( 布尔表达式 ){
    // 代码语句
}
```

#### switch 语句
```java
// 这里的变量由4种类型：byte，short，int，char
switch(变量){
    case 常量1:
        // 执行语句
        break;
    case 常量2:
        // 执行语句
        break;
    default:
        // 执行语句
}
```

## 循环语句

### while 循环

```java
while( 布尔表达式 ) {
   // 循环内容
}
```

### do…while 循环

do…while 循环至少会执行一次
```java
do {
    // 代码语句
}while(布尔表达式);
```
>注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。

### for 循环

```java
for(初始化; 布尔表达式; 更新) {
    // 代码语句
}
```
>关于 for 循环有以下几点说明：
* 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。
* 然后，检测布尔表达式的值
    * 如果为 true，循环体被执行。
    * 如果为false，循环终止，开始执行循环体后面的语句。
* 执行一次循环后，更新循环控制变量。
* 再次检测布尔表达式。循环执行上面的过程。

### 增强for

```java
for(声明语句 : 表达式) {
   // 代码句子
}
```

>* `break`语句：常用在循环语句种，用于**跳出整个循环**，执行循环后面的语句
* `continue`语句：常用在循环语句中，用于**跳出当前的这个循环**（或者是跳出本次循环），开始执行下一次的循环。